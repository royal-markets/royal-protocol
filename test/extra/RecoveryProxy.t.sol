// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {ProvenanceTest} from "../core/ProvenanceTest.sol";
import {RecoveryProxy} from "../../src/extra/RecoveryProxy.sol";
import {IIdRegistry} from "../../src/core/interfaces/IIdRegistry.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {SignatureCheckerLib} from "solady/utils/SignatureCheckerLib.sol";

contract RecoveryProxyTest is ProvenanceTest {
    RecoveryProxy public recoveryProxy;
    address public proxy;
    address public immutable RECOVERY_ENTRYPOINT_OWNER;

    uint256 internal _fromPrivateKey;
    uint256 internal _toPrivateKey;
    uint256 internal _recoveryProxyOwnerPrivateKey;

    event Recovered(uint256 indexed id, address indexed to);

    string public constant SEPOLIA_RPC_URL = "https://sepolia.base.org";

    function setUp() public override {
        super.setUp();

        _fromPrivateKey = 0xA11CE;
        _toPrivateKey = 0xB0B;
        _recoveryProxyOwnerPrivateKey = 0x0A1CE;

        recoveryProxy = new RecoveryProxy();
        bytes memory data =
            abi.encodeWithSelector(RecoveryProxy.initialize.selector, idGateway, vm.addr(_recoveryProxyOwnerPrivateKey));

        proxy = address(new ERC1967Proxy(address(recoveryProxy), data));
        recoveryProxy = RecoveryProxy(proxy);

        vm.prank(vm.addr(_recoveryProxyOwnerPrivateKey));
        recoveryProxy.addRecoverCaller(proxy);

        vm.startPrank(address(idGateway));
        address custody = vm.addr(_fromPrivateKey);
        idRegistry.register(custody, "username", proxy);
        vm.stopPrank();
    }

    function test_recover() public {
        uint256 id = 1;
        IIdRegistry.User memory originalUser = idRegistry.getUserById(id);
        address proxyAddress = address(proxy);
        assertEq(originalUser.recovery, proxyAddress);
        address to = vm.addr(_toPrivateKey);
        assertNotEq(to, originalUser.custody);
        uint256 deadline = block.timestamp + 1 days;

        bytes32 domainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes("RoyalProtocol_IdGateway")),
                keccak256(bytes("1")),
                block.chainid,
                address(idGateway)
            )
        );

        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                domainSeparator,
                keccak256(abi.encode(idGateway.RECOVER_TYPEHASH(), id, to, idGateway.nonces(to), deadline))
            )
        );

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(_toPrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);

        vm.prank(proxyAddress);
        vm.expectEmit();
        emit Recovered(id, to);
        recoveryProxy.recover(id, to, deadline, signature);

        IIdRegistry.User memory updatedUser = idRegistry.getUserById(id);
        assertEq(updatedUser.custody, to);
    }

    function test_recover_smart_wallet_deployed() public {
        vm.createSelectFork(SEPOLIA_RPC_URL);

        address to = address(0x788c7D29cCaABD81cfa68ab79bbD88cF08333835);
        // uint256 deadline = 4324234234;
        bytes32 digest = 0x108ac576c3a15418efbafba3e649d47be61521423136ccf7bba55755d663b78a;
        bytes memory signature =
            hex"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000001b70981566f0fe8bf7c15ab1711fbf4f01455734ac6822b89876ca5f4f80f31270a7c7222474aae33f40800f10ea71eb1f43299fedce407340511602413a117a30000000000000000000000000000000000000000000000000000000000000025f198086b2db17256731bc456673b96bcef23f51d1fbacdd7c4379ef65465572f1d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008a7b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a22566e4e4a4f41616c666375696247424e46585438396833633378352d395642393539715f63546c646a4d55222c226f726967696e223a2268747470733a2f2f6b6579732e636f696e626173652e636f6d222c2263726f73734f726967696e223a66616c73657d00000000000000000000000000000000000000000000";

        bool isValidERC6492 = SignatureCheckerLib.isValidERC6492SignatureNow(to, digest, signature);
        bool isValidBasic = SignatureCheckerLib.isValidSignatureNow(to, digest, signature);
        assertTrue(isValidERC6492);
        assertTrue(isValidBasic);
    }

    // This test shows that the way we're currently using isValidSignatureNow is not compatible with predeployed smart wallets
    function test_recover_smart_wallet_not_deployed() public {
        vm.createSelectFork(SEPOLIA_RPC_URL);

        address to = address(0x525522329EC693A03eA068FbEf3D71e61828Dd0A);
        // uint256 deadline = 4324234234;
        bytes32 digest = 0xa71f8ae86e974122a4efbd87dad106e146db5e30cfad3af6f1225e0c1c495bf8;
        bytes memory signature =
            hex"000000000000000000000000ca11bde05977b3631167028862be2a173976ca110000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000001e482ad56cb0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000ba5ed0c6aa8c49038f819e587e2633c4a9f428a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e43ffba36f00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000040b40a5980d77c2f33be33c7c19357a1dcc6fe6d0b5c50877e25a4409741fa09649e546d2bde37bc01ba575671b7ae92e1313ef2aa4c57e17993db50400b296c3d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000001ebdef85e6b42d74d0b326c53c70421889006f42fb785ea6ca687da93c1c342d01ff744a4a9f75b1577fe48d84ec7318c154baf75beddb06d7b7adc588feadf540000000000000000000000000000000000000000000000000000000000000025f198086b2db17256731bc456673b96bcef23f51d1fbacdd7c4379ef65465572f1d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008a7b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a2233724d345a4f4532676a6f537a5071656f65376a704e79766f5a5266396d4772655969644d684963722d6f222c226f726967696e223a2268747470733a2f2f6b6579732e636f696e626173652e636f6d222c2263726f73734f726967696e223a66616c73657d000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492";

        bool isValidERC6492 = SignatureCheckerLib.isValidERC6492SignatureNow(to, digest, signature);
        bool isValidBasic = SignatureCheckerLib.isValidSignatureNow(to, digest, signature);
        assertTrue(isValidERC6492);
        assertFalse(isValidBasic);
    }
}
